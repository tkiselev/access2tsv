/* Apache access log to tab-separated-values converter
 *
 * To build, you need:
 * Flex (https://github.com/westes/flex)
 * GCC, clang, or other C compiler. Clang produces better results IMO
 *
 * GNU Make has built-in rules that know about LEX programs.
 * You can just drop this in a folder and run:
 *
 *     make access2tsv CFLAGS="-O3 -march=native"
 *
 *
 * In the interest of speed, this program assumes input is valid and
 * well-formed, and will produce undefined behavior if it isn't.
 * In particular, the gperf section at the bottom will likely segfault
 * if it encounters an unknown three-letter month abbreviation.
 * Mis-quoted strings may produce a garbage line, but should no longer
 * crash the program entirely.
 *
 * -tkiselev
 */
%option nomain noyywrap 8bit fast

%{
struct Date {
    char year[5];
    char* month;
    char day[3];
    char timestr[9];
    char tzoffset[6];
};

char* get_month (const char *str);
%}

%x STR DATE
%%
%{
struct Date curr_date;
%}

[^ \"\[]+/[ ]   ECHO;               /* Print non-quoted field that's followed by a trailing space */
[ ]             putc('\t', yyout);  /* If not in a special ruleset, convert spaces to tabs */
\n              ECHO;               /* Preserve newlines */

\"              BEGIN(STR);         /* Start parsing a quoted field, switch to different set of rules */
<STR>[^\\\"]+   ECHO;               /* Print anything that's not a backslash or quote */
<STR>\\[\\\"]   putc(yytext[1], yyout);   /* Un-escape quotes and slashes */
<STR>[\"\n]     BEGIN(INITIAL);     /* Found the endquote, return to initial parsing rules 
                                       Also matches newline, to prevent crashes on mis-quoted fields*/

"["             BEGIN(DATE);        /* Start parsing the timestamp */
<DATE>{
([0-9]{2}:){2}[0-9]{2}  strcpy(curr_date.timestr, yytext);      /* Match the time, HH:MM:SS, and save it */
[0-9][0-9]/\/           strcpy(curr_date.day, yytext);          /* The day, 2 digits followed by / */
[0-9]{4}/:              strcpy(curr_date.year, yytext);         /* The year, 4 digits followed by : */
[A-Z][a-z][a-z]         curr_date.month = get_month(yytext);    /* Find the month abbreviation, use hash function to convert */
[+-][0-9]{4}            strcpy(curr_date.tzoffset, yytext);     /* Save the timezone string */
[/: ]                                                           /* Discard the timestamp delimiters */
"]"             {       /* Print the collected date in ISO format, and return to normal parsing rules */
                        fprintf(yyout, "%s-%s-%sT%s%s", curr_date.year, curr_date.month, curr_date.day, curr_date.timestr, curr_date.tzoffset);
                        BEGIN(INITIAL);
                }
}
%%
/* Generated by gperf, then manually cleaned up and compacted.
 * Using gperf to parse the month abbreviation makes it *slightly* faster.
 * 
 * Original gperf input:

%struct-type
struct month { char *name; char *number; };
%%
Jan, "01"
Feb, "02"
Mar, "03"
Apr, "04"
May, "05"
Jun, "06"
Jul, "07"
Aug, "08"
Sep, "09"
Oct, "10"
Nov, "11"
Dec, "12"
%%
char* get_month(char *str) {
    return in_word_set(str, 3)->number;
}

 */
struct month { char *name; char *number; };
__inline static unsigned int hash (register const char *str) {
  // gperf magic!
  static unsigned char asso_values[] = {
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  0, 14,  4,
      31, 10, 31, 14, 31, 31, 31, 31,  4, 31, 10, 15, 15, 31,  5, 31,  0,  5, 15, 31,
      31,  0, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,
      31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31
    };
  return asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[1]];
}

char* get_month (register const char *str) {
  // some more magic
  static struct month wordlist[] = {
      {"May", "05"}, {""}, {""}, {""}, {"Oct", "10"}, {"Mar", "03"}, {""}, {""}, {""},
      {"Jul", "07"}, {"Jan", "01"}, {""}, {""}, {""}, {"Dec", "12"}, {"Jun", "06"},
      {""}, {""}, {""}, {"Aug", "08"}, {"Apr", "04"}, {""}, {""}, {""}, {"Feb", "02"},
      {"Sep", "09"}, {""}, {""}, {""}, {""}, {"Nov", "11"}
    };
  return wordlist[hash(str)].number;
}

/* Main method.
 *
 * 0 args: read stdin, write stdout
 * 1 arg:  read file, write stdout
 * 2 args: read file, write file
 */

int main (int argc, char** argv) {
    ++argv, --argc;
    yyout = stdout;
    if (argc > 1)
        yyout = fopen(argv[1], "w");
    if (argc > 0)
        yyin = fopen(argv[0], "r");
    else
        yyin = stdin;
    yylex();
}
